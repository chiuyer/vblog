{"meta":{"title":"秋又来了","subtitle":"爱发呆的写手，不疯狂的浪客。","description":null,"author":"秋也","url":"https://chiuyer.github.io/vblog"},"pages":[{"title":"关于小主","date":"2021-04-22T12:02:15.358Z","updated":"2021-04-22T12:02:15.358Z","comments":true,"path":"about/index.html","permalink":"https://chiuyer.github.io/vblog/about/index.html","excerpt":"","text":"大家好，我是秋也, 一个很赖叽的艺术工作者。 有张爱吃的嘴, 有颗想浪的心。 时来诗情画意, 时来疯疯癫癫。 梦想能在江湖中留下侠名, 奈何克服不了惰性的根本。 允许自己犯错, 但不能一直堕落。 人生可以平凡, 但不能没有追求。 持续性的学习, 无论做人还是做事。 Email: chiu327@outlook.com Github: https://github.com/chiuyer"}],"posts":[{"title":"关于window.location","slug":"js/关于window.location","date":"2018-06-26T22:32:22.000Z","updated":"2021-04-22T12:02:15.357Z","comments":true,"path":"2018/06/27/js/关于window.location/","link":"","permalink":"https://chiuyer.github.io/vblog/2018/06/27/js/关于window.location/","excerpt":"","text":"案例： http://localhost:8028/cycle/mini-page/#/message-board?id=23232 location是window对象的属性，而所有的网页下的对象都是属于window作用域链中（这是顶级作用域），所以使用时是可以省略window。而top是指向顶级窗口对象，parent是指向父级窗口对象。 location 属性 属性 含义 值 protocol 协议 http: hostname 服务器的名字 此处本地指127.0.0.1 localhost（其他比如：zzfe.58corp.com or 10.242.20.1）等 port 端口 8028 pathname URL中主机名后的部分 /index.html search “?”后的部分，又称为查询字符串 ?id=23232 备注. hash 返回”#”之后的内容 “#/message-board?id=23232” host 等于hostname + port localhost:8028 origin 等于protocol+’//‘+hostname + port http://localhost:8028 —— 备注. href 当前页面的完整URL http://localhost:8028/cycle/mini-page/#/message-board?id=23232 location 方法 方法 含义 location.assign( url ) 1. 等价于 window.location = ‘http://m.baidu.com&#39; 2. 将新地址放到浏览器历史栈中，意味着转到新页面后“后退按钮”仍可以回到该页面。 location.replace( url ) 从浏览器历史栈中删除本页面，也就是说跳转到新页面后“后退按钮”不能回到该页面。目前IE、Chrome只是简单的跳转，只有Firefox会删除本页面的历史记录。 location.reload( force ) 重新载入当前页面。force为true时从服务器端重载；false则从浏览器缓存中重载，默认值false。 其他 场景 含义 top.location.href 本页面跳转 parent.location.href 是上一层页面跳转. window.open(url) 打开新窗口 this.location.href 当前页面打开URL页面, self.location.href 备注点 document.location.reload(true) || window.location.reload(true) 不要在微信场景下使用 window.location、document.location 和 document.URL window 对象 它是一个顶层对象,而不是另一个对象的属性即浏览器的窗口。 document 对象 该对象是window和frames对象的一个属性,是显示于窗口或框架内的一个文档。 document 只是属于window 的一个子对象 origin兼容：由于在Chrome window.location.origin 属性是支持的，但是在IE11不支持，会导致无法正常翻页。 search 为空？ search 与 hash 区别 location.search 是从当前URL的?号开始的字符串 location.hash 第一个”#”之后的内容 应用场景： search：搜索，需要刷新页面才能获取到 hash：锚点，快速定位当前页具体位置 原因： 因为查找优先级，若优先遍历到”?”则优先解析search，如果是”#”则优先解析hash。”?id=23232”串字符是属于”#/message-board?id=23232”这个串字符的，所以search为空。 12345678910111. http://localhost:8028/cycle/mini-page/#/message-board?id=23232打印：location.search：location.hash：#/message-board?id=232322. http://localhost:8028/cycle/mini-page/?id=23232#/message-board打印：location.search：?id=23232location.hash：#/message-board","categories":[{"name":"技术","slug":"技术","permalink":"https://chiuyer.github.io/vblog/categories/技术/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://chiuyer.github.io/vblog/tags/JS/"}]},{"title":"css modules 与 scoped 的不一样","slug":"css/css modules 与 scoped 的不一样","date":"2018-06-25T22:32:22.000Z","updated":"2021-04-22T12:02:15.357Z","comments":true,"path":"2018/06/26/css/css modules 与 scoped 的不一样/","link":"","permalink":"https://chiuyer.github.io/vblog/2018/06/26/css/css modules 与 scoped 的不一样/","excerpt":"","text":"What ? css 的作用域表现。 Css modules12是一个CSS文件，其中所有类名和动画名称默认为局部作用域。使用JS编译原生的CSS文件，使其具备模块化的能力，该文件需要import使用。 Scoped12在vue文件中的style标签上，有一个特殊的属性：scoped。此样式仅适用于当前组件元素，从而使组件之间的样式不互相污染。 How ?Css modules实现原理通过给样式名加hash字符串后缀的方式，实现特定作用域语境中的样式编译后的样式在全局唯一。 具体效果demo12345// webpack.config.js&#123; test: /\\.css$/, loader: &apos;style!css-loader?modules&amp;importLoaders=1&amp;localIdentName=[name]__[local]___[hash:base64:5]&apos; &#125; 1234567891011121314151617编译前 - vue 环境&lt;template&gt; &lt;div :class=&quot;$style.green&quot;&gt;demo demo&lt;/div&gt;&lt;/template&gt;&lt;style module&gt;.green &#123; color: green;&#125;&lt;/style&gt;编译后 - vue 环境&lt;div class=&quot;green_3UI7s9iz&quot;&gt;demo demo&lt;/div&gt;.green_3UI7s9iz &#123; color: green;&#125; ==由此可见== css module直接替换了类名，排除了用户设置类名影响组件样式的可能性。优点就是不必再担心命名约定。 $style.green 是个变量，即可在js中引用，引用方式为：this.$style.green。 modules 即为启用，localIdentName 是设置生成样式的命名规则。 应用场景只应用于某个组件，其他组件不适用。 ⚠️注意点 在处理动画animation的关键帧keyframes，动画名称必须先写： 比如，animation: deni .5s,能正常编译; animation: .5s deni, 则编译异常 css modules生效方式： 需要css-loader配置才能生效。 若使用的是style-loader，则需配置更换为vue-style-loader才可生效。 css modules如何解决权重问题？允许通过重命名或命名空间来封装样式规则，减少对选择器的约束，从而达到不需要特定方法就可舒服的使用类名。 当样式规则耦合到每个组件时，当不再使用组件时，样式也会被移除。 Scoped实现原理vue通过在DOM结构以及css样式上加唯一不重复的标记，以保证唯一，达到样式私有化模块化的目的。 具体效果demo12345678910111213// 编译前 demo.vue&lt;template&gt; &lt;div class=&quot;demo-c&quot;&gt;hello world!&lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;less&quot; scoped&gt; .demo-c &#123; width: 100%; height: 100px; background-color: green; color: #fff; &#125;&lt;/style&gt; 123456789// 编译后-dom&lt;div data-v-48baf84c=&quot;&quot; class=&quot;demo-c&quot;&gt;hello world!&lt;/div&gt;// 编译后-css.demo-c[data-v-48baf84c] &#123; width: 100%; height: 1.333333rem; background-color: green; color: #fff;&#125; 应用场景scoped css可以直接在能跑起来的vue项目中使用，且对应的样式只对该组件有效，不被其他组件污染。 ⚠️注意点 “权重加重”的意思： 如果我们要去修改这个样式，需要更高的权重去覆盖其样式。 由于css样式优先级的特性，scoped处理会造成每个样式的权重加重了。 若组件内部包含有子组件，只会给子组件的最外层标签加上当前组件的data属性： 一般父组件如果加了scoped，会比已设置过自己样式的子组件内除最外层标签的内层标签的权重低，所以不会影响他们的样式。 scoped会使标签选择器渲染变慢更多倍。 若用户再定义了相同的类名，也有可能会影响到组件的样式。 具有scoped属性的样式只会应用到当前元素和其子元素。Inline样式仍然比scoped样式优先级高，所以，最好避免使用inline样式。 Why ?目的 css 模块化 css 私有化：不被污染 css 复用性 解决CSS中的全局作用域问题 总结实现同一目的，比较它们的优缺点，css modules 配置并不麻烦且实现的整体效果更优于scoped css，在此个人更推荐使用css modules。 参考资料 https://github.com/css-modules/css-modules https://cn.vuejs.org/v2/guide/comparison.html#%E7%BB%84%E4%BB%B6%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%86%85%E7%9A%84-CSS https://vue-loader.vuejs.org/guide/css-modules.html#usage https://github.com/css-modules/webpack-demo https://webdesign.tutsplus.com/tutorials/solve-your-specificity-headaches-with-css-modules--cms-28973","categories":[{"name":"技术","slug":"技术","permalink":"https://chiuyer.github.io/vblog/categories/技术/"}],"tags":[{"name":"css","slug":"css","permalink":"https://chiuyer.github.io/vblog/tags/css/"}]},{"title":"webpack 问题整理","slug":"webpack/问题整理","date":"2017-07-28T14:37:45.000Z","updated":"2021-04-22T12:02:15.358Z","comments":true,"path":"2017/07/28/webpack/问题整理/","link":"","permalink":"https://chiuyer.github.io/vblog/2017/07/28/webpack/问题整理/","excerpt":"","text":"问题一复现场景12345执行:npm install webpack --save-dev错误提示:npm ERR! Refusing to install webpack as a dependency of itself 解决方案 1将package.json中的name换个名称, 再执行npm install webpack --save-dev","categories":[{"name":"技术","slug":"技术","permalink":"https://chiuyer.github.io/vblog/categories/技术/"}],"tags":[{"name":"打包工具","slug":"打包工具","permalink":"https://chiuyer.github.io/vblog/tags/打包工具/"}]},{"title":"设计模式 了解之工厂模式","slug":"design_pattern/factory","date":"2017-07-25T22:32:22.000Z","updated":"2021-04-22T12:02:15.357Z","comments":true,"path":"2017/07/26/design_pattern/factory/","link":"","permalink":"https://chiuyer.github.io/vblog/2017/07/26/design_pattern/factory/","excerpt":"","text":"工厂模式定义工厂模式, 定义了一个创建对象的接口，由子类决定要实例化的类是哪一个，工厂方法将类的实例化推迟到子类。 简单工厂模式, 使用一个类来生成实例。 复杂工厂模式, 使用子类来决定一个成员变量应该是哪个具体的类的实例。 使用场景创建一个需要被封装的新对象, 通过让子类决定需要创建哪个对象, 从而实现对象创建过程被封装的目的。 用于创建一个产品的实例, 创建对象的方法使用的是继承。 解决的问题创建一个对象常常需要复杂的过程，可能会导致大量的重复代码，也可能提供不了足够级别的抽象。 创建对象习惯使用 new 关键字和类构造函数（主要还是对象字面量），问题在于这样会导致两个类之间产生依赖性。 工厂模式主要是消除两个类依赖性的模式。 优缺点优点: 消除对象间的耦合，通过使用工程方法而不是new关键字, 实例化实现在子类, 防止代码重复。 缺点: 实现案例 常见实现方式 12345function Role () &#123; this.name = name;&#125;Role.prototype es6实现方式 12345function Role () &#123; this.name = name;&#125;Role.prototype","categories":[{"name":"技术","slug":"技术","permalink":"https://chiuyer.github.io/vblog/categories/技术/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://chiuyer.github.io/vblog/tags/设计模式/"}]},{"title":"vue 了解之生命周期","slug":"vue/生命周期","date":"2017-07-24T00:57:24.000Z","updated":"2021-04-22T12:02:15.358Z","comments":true,"path":"2017/07/24/vue/生命周期/","link":"","permalink":"https://chiuyer.github.io/vblog/2017/07/24/vue/生命周期/","excerpt":"","text":"生命周期 vue 1.0 vue 2.0 描述 init beforeCreate 初始化 参考文献1, 中文文档","categories":[{"name":"技术","slug":"技术","permalink":"https://chiuyer.github.io/vblog/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://chiuyer.github.io/vblog/tags/vue/"}]},{"title":"ES6 了解之解构赋值","slug":"es6/解构赋值","date":"2017-07-23T23:17:04.000Z","updated":"2021-04-22T12:02:15.357Z","comments":true,"path":"2017/07/24/es6/解构赋值/","link":"","permalink":"https://chiuyer.github.io/vblog/2017/07/24/es6/解构赋值/","excerpt":"","text":"定义解构赋值, 就是将对象的属性/数组的元素值, 赋值给一个变量. 默认值* 数组的解构赋值应用场景, 成功的情况解构成功的定义: 左边的每个变量值都不是undefined, 说明此解构是成功的. 完全解构: 左右元素个数等于右边元素个数, 且左到右的匹配模式是一致的.(嵌套数组也一样的逻辑) 1234let arr = [1, 2, 3, 8];let [x, y, z, h] = arr;结果:x=1, y=2, z=3, h=8 不完全解构: 左边元素个数小于右边元素个数, 且左到右的匹配模式是一致的.(嵌套数组也一样的逻辑) 1234let arr = [1, 2, 3, 8];let [x, y, z] = arr;结果:x=1, y=2, z=3 应用场景, 失败的情况解构失败的定义: 只要左边任一变量值是undefined, 就说明此解构不成功. 右边是非数组或空数组, 左边是非空数组, 都会造成解构不成功. 左边元素个数大于右边元素个数( 从左往右匹配 ) 对象的解构赋值应用场景, 成功的情况应用场景, 失败的情况","categories":[{"name":"技术","slug":"技术","permalink":"https://chiuyer.github.io/vblog/categories/技术/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://chiuyer.github.io/vblog/tags/ES6/"}]},{"title":"ES6 了解之函数","slug":"es6/函数","date":"2017-07-23T22:17:04.000Z","updated":"2021-04-22T12:02:15.357Z","comments":true,"path":"2017/07/24/es6/函数/","link":"","permalink":"https://chiuyer.github.io/vblog/2017/07/24/es6/函数/","excerpt":"","text":"箭头函数基本用法 箭头指向的是返回值 1234567891011121314151617181920212223242526let a = () =&gt; 1;let b = x =&gt; x;let c = (x, y) =&gt; x+y;// 或者 代码块部分多于一条语句 let c = (x, y) =&gt; &#123; return x+y; &#125;let d = (x, y) =&gt; (&#123; id: x, name: y &#125;);// 返回值为一个对象时, 需要() 包住该对象值. 或者 let d = (x, y) =&gt; &#123; return &#123;id: x, name: y&#125; &#125;;等同于let a = function () &#123; return 1;&#125;let b = function (x) &#123; return x;&#125;let c = function (x, y) &#123; return x+y;&#125;let d = function (x, y) &#123; return &#123; id: x, name: y &#125;;&#125; 形参方式用法1234567[1, 2, 3].map(x =&gt; x + 1); // 返回结果 [2, 3, 4]等同于[1, 2, 3].map(function (x) &#123; return x + 1;&#125;); 和rest参数结合的用法 以形参方式传值时, 默认从左到右依次传参, 其余的参数合为一个 1234567891011场景一:let demo = (...nums) =&gt; nums;demo(1, 2, 3, 4, 5); // [1, 2, 3, 4, 5]场景二:let demo = (num01, ...num02) =&gt; nums;demo(1, 2, 3, 4, 5); // [1, [2, 3, 4, 5]] 延伸知识点: Rest参数 函数参数的默认值常用写法1234567891011121314function demo(x, y) &#123; y = y || &apos;HChiu&apos;; console.log(x, y);&#125;正常:demo(&apos;Hello&apos;) // Hello HChiudemo(&apos;Hello&apos;, &apos;Anuo&apos;) // Hello Anuodemo(&apos;Hello&apos;, &apos;false&apos;) // Hello falsedemo(&apos;Hello&apos;, true) // Hello true缺点: 当传参值为fasle或者空字符串时, 该值会被默认值取代.demo(&apos;Hello&apos;, false) // Hello HChiudemo(&apos;Hello&apos;, &apos;&apos;) // Hello HChiu ES6写法12345678910111213141516171819202122场景一:function demo(x, y = &apos;HChiu&apos;) &#123; console.log(x, y);&#125;demo(&apos;Hello&apos;) // Hello HChiudemo(&apos;Hello&apos;, false) // Hello falsedemo(&apos;Hello&apos;, &apos;&apos;) // Hellodemo(&apos;Hello&apos;, &apos;undefined&apos;) // Hello undefineddemo(&apos;Hello&apos;, undefined) // Hello HChiu场景二:function demo (x = 0, y = 0) &#123; this.x = x; this.y = y;&#125;let t = new demo(); // &#123;x: 0, y: 0&#125; ⚠ ️注意: 以形参的方式, 已经是默认的变量声明, 无需再重复声明同一个变量名, 报错 Uncaught SyntaxError: Unexpected identifier 形参的声明, 同样也需要避免重复. DEMO: 1234567891011121314151617181920场景一:function demo(x, x, y) &#123;return x+x+y&#125;demo(1, 2, 3); // 7 , 前一个x, 会被后者覆盖场景二:function demo(x, x = 3, y) &#123; return x+x+y;&#125;demo(1, 2) // 不允许重复参数名, Uncaught SyntaxError: Duplicate parameter name not allowed in this context场景三:function demo(x) &#123; let x;&#125;demo(1); // Uncaught SyntaxError: Unexpected identifier 与解构赋值默认值的结合使用12345678function demo(&#123;x, y = 1&#125;) &#123; console.log(x, y);&#125;demo(&#123;&#125;) // undefined 1demo(&#123;x: 2&#125;) // 2 1demo(&#123;x: 2, y: 2&#125;) // 2 2demo() // TypeError: Cannot read property &apos;x&apos; of undefined 延伸知识点: 解构赋值","categories":[{"name":"技术","slug":"技术","permalink":"https://chiuyer.github.io/vblog/categories/技术/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://chiuyer.github.io/vblog/tags/ES6/"}]},{"title":"ES6 了解之简介","slug":"es6/初步了解和参考文献","date":"2017-07-23T11:37:45.000Z","updated":"2021-04-22T12:02:15.357Z","comments":true,"path":"2017/07/23/es6/初步了解和参考文献/","link":"","permalink":"https://chiuyer.github.io/vblog/2017/07/23/es6/初步了解和参考文献/","excerpt":"","text":"什么是ES6 ? ES6, 全称ECMAScript 6.0, 是JaveScript的下一个版本标准, 2015.06发版.目的: 提供了大量复杂度不同的特性, 来满足不同复杂程度的应用开发. ECMAScript 与 JavaScript 的关系 前者是后者的规格, 后者是前者的实现. ES5 与 ES6 的区别1. ES5 新增特性 strict模式 1&apos;use strict&apos;; // 严格模式，限制一些用法 Array新增方法 12345678910everysomeforEachfilterindexOflastIndexOfisArraymapreducereduceRight Object新增方法 12345678910Object.getPrototypeOfObject.createObject.getOwnPropertyNamesObject.definePropertyObject.getOwnPropertyDescriptorObject.definePropertiesObject.keysObject.preventExtensions / Object.isExtensibleObject.seal / Object.isSealedObject.freeze / Object.isFrozen 其他方法 123Function.prototype.bindString.prototype.trimDate.now 2. ES6 新增特性 ES5 作用域: 全局作用域； 函数作用域。 es6了解之主要知识点梳理 参考文献 阮一峰 ES6 入门 Nicholas C. Zakas ECMAScript 6 destructuring gotcha Mozilla Web开发者博客 ES6 In Depth 探秘ES6资讯 备注: es6 主要知识点梳理, 主要是以上参考文献总结梳理","categories":[{"name":"技术","slug":"技术","permalink":"https://chiuyer.github.io/vblog/categories/技术/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://chiuyer.github.io/vblog/tags/ES6/"}]},{"title":"ES6 了解之var、let和const声明","slug":"es6/var、let和const声明","date":"2017-07-23T11:37:45.000Z","updated":"2021-04-22T12:02:15.357Z","comments":true,"path":"2017/07/23/es6/var、let和const声明/","link":"","permalink":"https://chiuyer.github.io/vblog/2017/07/23/es6/var、let和const声明/","excerpt":"","text":"基本使用方式 let声明的变量只有在块级作用域内有效, 以外就会报not defined异常. 应用场景1. 在for循环中使用let和var的声明 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586场景一:for (let i = 0; i &lt; 10; i++) &#123;&#125;console.log(&quot;外i：&quot;+i);场景一输出结果:Uncaught ReferenceError: i is not defined at &lt;anonymous&gt;:6:20场景二:for (let i = 0; i &lt; 10; i++) &#123; console.log(&quot;内i：&quot;+i);&#125;console.log(&quot;外i：&quot;+i);场景二输出结果:内i：0内i：1内i：2内i：3内i：4内i：5内i：6内i：7内i：8内i：9Uncaught ReferenceError: i is not defined at &lt;anonymous&gt;:6:20场景三:var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(&quot;内i：&quot;+i); &#125;&#125;a[6]();console.log(&quot;外i：&quot;+i);场景三输出结果:内i：6Uncaught ReferenceError: i is not defined at &lt;anonymous&gt;:8:19场景四:var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(&quot;内i：&quot;+i); &#125;&#125;a[6]();console.log(&quot;外i：&quot;+i);场景四输出结果:内i：10外i：10场景五:for (let i = 0; i &lt; 3; i++) &#123; let i = &apos;abc&apos;; console.log(i);&#125;场景五输出结果:abcabcabc场景六:for (var i = 0; i &lt; 3; i++) &#123; var i = &apos;abc&apos;; console.log(i);&#125;场景六输出结果:abc 以上充分证明了: 在循环体中, 如果用let声明同个变量名, 那么会有多个独立作用域的; 在循环体中, 如果用var声明同一个变量, 后声明的变量会覆盖前面的, 只会存在一个作用域. 2. 未声明, 直接调用时 1234567891011121314151617场景一:console.log(f);var f = 2;场景一输出结果:undefined (有此变量, 只不过其变量值默认为undefined, 此现象称为: var 变量提升)场景二:console.log(fd);let fd = 2;场景二输出结果:Uncaught ReferenceError: fd is not defined (let 直接报未定义异常) 12345678var tmp = 123;if (true) &#123; tmp = &apos;abc&apos;; // ReferenceError console.log(&quot;tmp1:&quot;+tmp); let tmp; //console.log(&quot;tmp2:&quot;+tmp);&#125; ⚠️注意点 var 声明变量, 该变量会绑到window let 声明变量, 该变量不会绑到window上","categories":[{"name":"技术","slug":"技术","permalink":"https://chiuyer.github.io/vblog/categories/技术/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://chiuyer.github.io/vblog/tags/ES6/"}]},{"title":"mac和win环境好用的工具","slug":"other/technology-tools","date":"2017-07-13T10:45:28.000Z","updated":"2021-04-22T12:02:15.358Z","comments":true,"path":"2017/07/13/other/technology-tools/","link":"","permalink":"https://chiuyer.github.io/vblog/2017/07/13/other/technology-tools/","excerpt":"","text":"FTP/SFTP 客户端transmitWinSCP 多个host代理 切换工具switchhosts host代理工具和抓包工具CharlesFiddler 极简录屏工具，直接生成 gif 格式licecap svn 客户端cornerstoneTortoiseSVN 画图工具百度脑图XmindiThoughtsXMindNode 前端编程工具, 自身常用WebstormSublime 日常即时记, 笔记有道云印象笔记 markdown编写, 常用MarkdownPadMou","categories":[{"name":"技术","slug":"技术","permalink":"https://chiuyer.github.io/vblog/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://chiuyer.github.io/vblog/tags/工具/"}]},{"title":"mac环境 之 IE兼容调试","slug":"other/technology-browser-mac","date":"2017-07-11T11:46:21.000Z","updated":"2021-04-22T12:02:15.357Z","comments":true,"path":"2017/07/11/other/technology-browser-mac/","link":"","permalink":"https://chiuyer.github.io/vblog/2017/07/11/other/technology-browser-mac/","excerpt":"","text":"调试方案 Safari Develop –&gt; user agent (开发 –&gt; 用户代理), 跳到IE模式 360浏览器 ( 和IE同内核 ) 双系统安装, 再安装IE浏览器 chrome 安装IE插件","categories":[{"name":"技术","slug":"技术","permalink":"https://chiuyer.github.io/vblog/categories/技术/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://chiuyer.github.io/vblog/tags/浏览器/"}]},{"title":"命名规范","slug":"other/technology-naming-conventions","date":"2017-07-03T22:27:14.000Z","updated":"2021-04-22T12:02:15.358Z","comments":true,"path":"2017/07/04/other/technology-naming-conventions/","link":"","permalink":"https://chiuyer.github.io/vblog/2017/07/04/other/technology-naming-conventions/","excerpt":"","text":"通用HTML布局 wrap 用于最外层 header 头部 main 主要内容 main-center 中部布局 main-left 左侧布局 main-right 右侧布局 nav 导航条 content 内容 footer 底部 表单布局列表布局","categories":[{"name":"技术","slug":"技术","permalink":"https://chiuyer.github.io/vblog/categories/技术/"}],"tags":[{"name":"命名规范","slug":"命名规范","permalink":"https://chiuyer.github.io/vblog/tags/命名规范/"}]},{"title":"dos常用命令","slug":"other/technology-dos","date":"2017-04-13T12:01:26.000Z","updated":"2021-04-22T12:02:15.358Z","comments":true,"path":"2017/04/13/other/technology-dos/","link":"","permalink":"https://chiuyer.github.io/vblog/2017/04/13/other/technology-dos/","excerpt":"","text":"1. 打印树状结构的文件目录（windows） 查询 1tree /? 目录结构会打印到tree.txt文件中 1tree /f &gt; tree.txt pwd 查看当前路径ls 查看所有当前路径的子文件cd 改变路径 2. 打印树状结构的文件目录（mac） 模拟tree: 1find . -print | sed -e &apos;s;[^/]*/;|____;g;s;____|; |;g&apos; 添加到你的.bash_profile文件 1echo &quot;alias tree=\\&quot;find . -print | sed -e &apos;s;[^/]*/;|____;g;s;____|; |;g&apos;\\&quot;&quot; &gt;&gt; ~/.bash_profile &amp;&amp; source ~/.bash_profile","categories":[{"name":"技术","slug":"技术","permalink":"https://chiuyer.github.io/vblog/categories/技术/"}],"tags":[{"name":"dos常用命令","slug":"dos常用命令","permalink":"https://chiuyer.github.io/vblog/tags/dos常用命令/"}]},{"title":"hexo博客","slug":"other/technology-hexo","date":"2017-03-08T14:50:42.000Z","updated":"2021-04-22T12:02:15.358Z","comments":true,"path":"2017/03/08/other/technology-hexo/","link":"","permalink":"https://chiuyer.github.io/vblog/2017/03/08/other/technology-hexo/","excerpt":"","text":"配置环境 安装node 安装git 申请github账号 安装hexo1$ sudo npm install -g hexo 初始化, 并创建新文件1$ hexo init hoochiu.github.io 生成静态文件1$ hexo g(或者hexo generate) 本地启动1$ hexo server 配置github 创建Repository, 仓库名和用户名一致[your_user_name.github.io] 创建ssh key, 仓库与本地关联 在根目录下的_config.yml中配置(注意: “:”后保持空格) 1234deploy: type: git repository: git@github.com:your_user_name/your_user_name.github.io.git branch: 分支名称(没有创建新分支就是master) git命令部署1npm install hexo-deployer-git --save 部署步骤123456hexo clean #删除public目录hexo generate #生成静态页面至public目录hexo deploy #将.deploy目录部署到GitHub或者hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 其他常用命令12hexo new &quot;demo&quot; #创建文章hexo new page &quot;demo&quot; #创建页面 问题整理问题一: hexo deploy 后竟然将整个根目录上传到了master上解决方案: 将根目录的.deploy_git删除, 再执行hexo clean &amp;&amp; hexo g &amp;&amp; hexo d即可","categories":[{"name":"技术","slug":"技术","permalink":"https://chiuyer.github.io/vblog/categories/技术/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://chiuyer.github.io/vblog/tags/hexo/"}]},{"title":"fiddler抓取https请求","slug":"other/technology-fiddler","date":"2017-03-07T13:50:42.000Z","updated":"2021-04-22T12:02:15.358Z","comments":true,"path":"2017/03/07/other/technology-fiddler/","link":"","permalink":"https://chiuyer.github.io/vblog/2017/03/07/other/technology-fiddler/","excerpt":"","text":"fiddler配置 Tools –&gt; fiddler options —&gt; 安装证书最后一步在手机端代理本地服务器，用手机浏览器访问， 安装fiddler root证书, 代理服务器+端口号 遇到问题整理问题一: UC浏览器代理不上解决方案: UC设置关闭广告过滤、极速流量设置和云加速","categories":[{"name":"技术","slug":"技术","permalink":"https://chiuyer.github.io/vblog/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://chiuyer.github.io/vblog/tags/工具/"}]},{"title":"charles代理抓取https请求","slug":"other/technology-charles","date":"2017-02-28T23:14:04.000Z","updated":"2021-04-22T12:02:15.358Z","comments":true,"path":"2017/03/01/other/technology-charles/","link":"","permalink":"https://chiuyer.github.io/vblog/2017/03/01/other/technology-charles/","excerpt":"","text":"注意！！！！！手机同网域下代理需要关闭电脑 的防火墙~手机代理需要打开浏览器安装证书https://www.charlesproxy.com/getssl","categories":[{"name":"技术","slug":"技术","permalink":"https://chiuyer.github.io/vblog/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://chiuyer.github.io/vblog/tags/工具/"}]},{"title":"浏览器 了解之内核差异","slug":"other/technology-browser","date":"2017-02-01T01:09:09.000Z","updated":"2021-04-22T12:02:15.358Z","comments":true,"path":"2017/02/01/other/technology-browser/","link":"","permalink":"https://chiuyer.github.io/vblog/2017/02/01/other/technology-browser/","excerpt":"","text":"内核小常识 主流内核 Trident 内核：IE, MaxThon, TT, The World, 360, 搜狗浏览器等 Gecko 内核： Netscape6及以上版本，FF，MozillaSuite/SeaMonkey等 Presto 内核： Opera7及以上 Webkit 内核： Safari， Chrome等","categories":[{"name":"技术","slug":"技术","permalink":"https://chiuyer.github.io/vblog/categories/技术/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://chiuyer.github.io/vblog/tags/浏览器/"}]},{"title":"git常用命令","slug":"other/technology-git","date":"2016-07-12T05:44:17.000Z","updated":"2021-04-22T12:02:15.358Z","comments":true,"path":"2016/07/12/other/technology-git/","link":"","permalink":"https://chiuyer.github.io/vblog/2016/07/12/other/technology-git/","excerpt":"","text":"分支操作 创建分支 12$ git branch daily/1.0.0$ git push origin daily/1.0.0 删除分支 注意: 不能在当前分支删除此分支 12$ git branch -d daily/1.0.0$ git push origin :daily/1.0.0 查看分支 1$ git branch -a 切换分支 12$ git checkout -b dev origin/dev #远程仓库有dev分支, 但本地仓库没有时, 需要在本地创建新的dev分支$ git checkout dev #本地有dev分支, 直接切换 查看目前状态(是否有本地更改)1$ git status 更新1$ git pull git提交123$ git add --all 或 git add .$ git commit -m &apos;first commit&apos;$ git push origin master 下载某分支的内容，且本地独立创建master 为分支名称, myblog 为创建的目录 1$ git clone -b master git@github.com:HooChiu/hoochiu.github.io.git myblog 删除文件(远程仓库)123$ git rm -r --cached 文件名称$ git commit -m &quot;注释&quot;$ git push 回滚12$ git reset --hard 3d51c955ddfc7a78da531b5c42b34ca2b60ea47b（某次commit编码）$ git push -f origin 分支名 上线(merge到master分支)1234$ git checkout master$ git pull$ git merge 分支名 #将分支合并到master上$ git push origin master 删除tag12$ git tag -a v1.0.0 -m &apos;标记备注&apos; #针对某一时间点做标记$ git push origin v1.0.0 #v1.0.0 是本次提交过程中的版本号 创建tag(merge到master后需要打tag标记下上线版本)1234$ git tag -d v1.0.0 #删除本地tag$ git push origin :v1.0.0 #删除远程v1.0.0 tag 方案一$ git push origin --delete tag v1.0.0 #删除远程v1.0.0 tag 方案二$ git push origin :refs/tags/v1.0.0 #删除远程v1.0.0 tag 方案三 提交日志log12$ git log #查看所有提交记录$ git log --author &apos;HooChiu&apos; #查看某用户的提交记录 问题整理问题一: git add . 时报错 解决方案: rm -f ./.git/index.lock 问题二: Please enter a commit message to explain why this merge is necessary,especially if it merges an updated upstream into a topic branch.Lines starting with ‘#’ will be ignored, and an empty message aborts the commit. 问题复现场景: git pull 或者合并分支时 解决方案: 按键盘字母 i 进入insert模式 修改最上面那行黄色合并信息,可以不修改 按键盘左上角”Esc” 输入”:wq”,注意是冒号+wq,按回车键即可或者”:wq!” 问题三:12345678➜ ~ brew -v Homebrew &gt;1.2.0 (no git repository) Homebrew/homebrew-core (no git repository) Warning: git 2.14.1 is already installed git -v xcode-select: note: no developer tools were found at &apos;/Applications/Xcode.app&apos;, requesting install. Choose an option in the dialog to download the command line developer tools. 解决方案: export PATH=”/usr/local/bin:$PATH” 12➜ ~ git --versiongit version 2.14.1","categories":[{"name":"技术","slug":"技术","permalink":"https://chiuyer.github.io/vblog/categories/技术/"}],"tags":[{"name":"git","slug":"git","permalink":"https://chiuyer.github.io/vblog/tags/git/"}]},{"title":"总结 之如何保证高效开发","slug":"work_efficiency/总结之如何保证高效开发","date":"2016-05-14T13:07:04.000Z","updated":"2021-04-22T12:02:15.358Z","comments":true,"path":"2016/05/14/work_efficiency/总结之如何保证高效开发/","link":"","permalink":"https://chiuyer.github.io/vblog/2016/05/14/work_efficiency/总结之如何保证高效开发/","excerpt":"","text":"工作流程 需求沟通会/需求评审会 ( 了解需求背景, 讨论需求的合理性, 明确需求内容, 是否依赖第三方等 ) 需求排期 ( ue - ui - FE/RD - 联调 - 提测 - QA - 上线 ) 开发 ( 前端和后端开发 ) 联调 ( 前后端数据接口联调 ) 提测 ( 提测前需要UE和UI验收 ) 上线 ( 上线前需要PM验收, QA沙箱回归; 上线后需要UE, UI和PM验收, QA线上回归, 开发线上观察) 开发前 明确需求背景, 需求目的, UI是否是最终版, 埋点或者需求文档是否需要更改 明确自身的工作内容( 如不熟悉的部分, 应该在需求会上提前提出需要调研或了解时间 ) 明确是否有其他开发依赖 需求/项目 颗粒化 ( 尽量拆细需求, 保证每半个工作日的排期都在合理范围内, 明确开发优先级, 尽可能预留自测和优化的时间 ) 预留1~2个工作日的buffer( 较大的需求情况下 ) 开发中遇到问题 影响进度: 以邮件, 拉组群, 将问题抛出, 集思广益, 明确问题原因和解决方案 不影响主要进度: 及时和PM沟通, 确定处理方案 开发后 总结问题 需求迭代的同时, 保证代码优化迭代进度跟上( 确保每次开发标准一致 ) 总结 UE/UI/QA 提出的需要改动/修复的问题, 不需要提一个就改一个, 而是对问题进行分类, 批量解决并给出解决时间和提测 UI图, 需求和埋点文档交接后, 不急于开发, 而是仔细过一遍, 确认是否有不合理的地方需要修改","categories":[{"name":"个人总结","slug":"个人总结","permalink":"https://chiuyer.github.io/vblog/categories/个人总结/"}],"tags":[{"name":"工作效率","slug":"工作效率","permalink":"https://chiuyer.github.io/vblog/tags/工作效率/"}]},{"title":"markdown基础语法整理","slug":"other/technology-markdown","date":"2016-02-22T23:34:19.000Z","updated":"2021-04-22T12:02:15.358Z","comments":true,"path":"2016/02/23/other/technology-markdown/","link":"","permalink":"https://chiuyer.github.io/vblog/2016/02/23/other/technology-markdown/","excerpt":"","text":"标题级别(一共六级)（建议在#后加一个空格比较标准） 通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。 在文字开头加上 “#”，通过“#”数量表示几级标题。（共1~6级标题，级别越小字体越大） 列表无序（实现方式：- 或 * 或 +） 列表1 列表2 列表3 123- 列表1* 列表2+ 列表3 有序（实现方式：数字） 列表1 列表2 121. 列表12. 列表2 引用1&gt; 引用语法 图片与链接图片为： 链接为：图片链接 123图片为：![](/images/avatar.jpeg)链接为：[图片链接](https://github.com/HooChiu) 表格12345678910&lt;table &gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;表格1&lt;/td&gt;&lt;td&gt;表格1&lt;/td&gt;&lt;td&gt;表格1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格1&lt;/td&gt;&lt;td&gt;表格1&lt;/td&gt;&lt;td&gt;表格1&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 粗体与斜体斜体实现方式： 斜体文字 \\ 斜体文字 (单个*或_闭包) 粗体实现方式： 粗体文字 \\ 粗体文字(两个*或_闭包) 分割线三个***或者—或者___实现 插入代码 实现方式：连续四个空格或者Tab 1234567&lt;table &gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;表格1&lt;/td&gt;&lt;td&gt;表格1&lt;/td&gt;&lt;td&gt;表格1&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://chiuyer.github.io/vblog/categories/技术/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://chiuyer.github.io/vblog/tags/markdown/"}]}]}